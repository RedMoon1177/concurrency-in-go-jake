package main

import "fmt"

func main() {

	// CASE 1: Example with Unbuffered Channel and Goroutine
	// In this modified example, the goroutine sends the value "hello" into the channel,
	// and the main goroutine receives it and prints it.
	// This avoids the deadlock because the send and receive operations can proceed concurrently.
	// c := make(chan string)

	// go func() {
	// 	c <- "hello"
	// }()

	// msg := <-c
	// fmt.Println(msg)

	// CASE 2: Example with Buffered Channel
	// This line creates a buffered channel of strings with a capacity of 1/2/....
	// Channels are a way for goroutines to communicate with each other and synchronize their execution.
	// A buffered channel can hold a limited number of values without a corresponding receiver ready to receive them.
	c := make(chan string, 2)
	c <- "hello"
	c <- "anne"
	msg := <-c
	fmt.Println(msg)
	msg = <-c
	fmt.Println(msg)
}

// //////// LESSON LEARNT ////////////////////////////////////////////////////////////////////////
// BUFFERED Channel: A buffered channel with a capacity allows
// you to send values into the channel even if there isn't an immediate receiver.
// The program continues execution as long as the buffer isn't full.

// UNBUFFERED Channel: An unbuffered channel (capacity 0)
//  requires a receiver to be ready to receive the value at the same time a sender sends it.
//  If there is no receiver ready, the send operation blocks (waits).

// DEADLOCK Situation
// Since the send operation blocks and there's no receiver, the program reaches a deadlock:
// all goroutines are asleep, waiting for an operation that will never happen.
///////////////////////////////////////////////////////////////////////////////////////////////////
